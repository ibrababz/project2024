# -*- coding: utf-8 -*-
"""Copy of Project_6771_478.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NVesLDQayzZAw7gYXljKWpqp_22aNd9g
"""
import numpy as np
import cv2 as cv
import imgaug.augmenters as iaa
from copy import deepcopy

def copyTemp(temp):
    if temp is not None:
        return temp.deepcopy()
    else:
        return temp
    
def augmentXData(X_train, seq):
    if seq is not None:
        return seq.deepcopy()(images = X_train)
    else:
        return deepcopy(X_train)
    
def normListBy(iList, iNorm):
    oList = []
    for wEle in iList:
        oList.append(wEle/iNorm)
    return oList

def transform_pts(x,y,t12):
    p1 = np.array([[np.float(x)], [np.float(y)], [1]])
    p1 = t12.dot(p1)
    x1, y1 = p1[0,0], p1[1,0]
    return x1, y1

def to_center(srcCenter, dim):
    W, H = dim
    return to_point(srcCenter, (W//2, H//2))

def to_origin(srcCenter):
    return to_point(srcCenter, (0,0))

def to_point(srcCenter, destCenter):
    srcX, srcY = srcCenter
    destX, destY = destCenter
    tx, ty = destX-srcX, destY -srcY
    return trans(tx, ty)

def inverse_transform_matrix(t12):
    return np.concatenate(
        (np.concatenate((t12[:2,:2].transpose(), -t12[:2,:2].transpose().dot(t12[:2, 2,None])), axis = 1),np.array([[0,0,1]])), axis = 0)

def rotz(angle):
    rad = angle*np.pi/180
    c, s= np.cos(rad), np.sin(rad)
    return np.array([[c,-s,0], [s, c, 0], [0, 0 , 1]])

def scale(x = 1, y = 1):
    return np.array([[x,0,0], [0, y, 0], [0, 0 , 1]])

def trans(tx = 0, ty = 0):
    return np.array([[1,0,tx], [0, 1, ty], [0, 0 , 1]])
    
def getWarpMatrix(iCenter, dim, angle = 0, scaleXY = (1,1), transXY = (0,0)):
    #this returns the transformation matrix of the image rotated/scaled at iCenter
    #then translated therefrom
    scaleX, scaleY = scaleXY
    tx, ty = transXY
    return trans(tx,ty)@to_center((0,0),dim)@scale(scaleX, scaleY)@rotz(angle)@to_origin(iCenter)

def warpImage(im, iCenter, dim, angle = 0, scaleXY = (1,1), transXY = (0,0)):
    t12 = getWarpMatrix(iCenter, dim, angle, scaleXY, transXY)
    return cv.warpAffine(im,  t12[:2,:], dim)

def getTransFromPolar(r, angleDeg):
    angleRad = angleDeg*np.pi/180
    return r*np.cos(angleRad), r*np.sin(angleRad)

def getAngleBounds(n):
    angleList = [0]
    for i in range(n):
        angleList.append(np.int32((i+1)*360/n))
    return angleList      

def affine_augments():
    flipX = iaa.Fliplr(0.5)
    flipY = iaa.Flipud(0.5)
    rot_image = iaa.Affine(rotate = (-45,45))
    shr = iaa.Affine(shear = {"y":(-15,15), "x": (-15,15)})#{"y":(-15,15), "x": (-15,15)} (-5,5) (3,3)
    scale = iaa.Affine(scale = (0.9,1.1))
    translateX = iaa.TranslateX(percent=(-0.15, 0.15))
    translateY = iaa.TranslateY(percent=(-0.15, 0.15))
    seq = iaa.Sequential([flipX, flipY, rot_image, shr, scale, translateX, translateY])
    return seq



def augments():
  flipX = iaa.Fliplr(0.5)#(0.5)
  flipY = iaa.Flipud(0.5)#(0.5)
  rot_image = iaa.Affine(rotate = (-45,45)) #(-45,45), (-20, 20)
  shr = iaa.Affine(shear = {"y":(-20,20), "x": (-20,20)})#{"y":(-15,15), "x": (-15,15)} (-5,5) (3,3)
  scale = iaa.Affine(scale = (0.90,1.10))
  translateX = iaa.TranslateX(percent=(-0.15, 0.15)) #USUALLY 0.1
  translateY = iaa.TranslateY(percent=(-0.15, 0.15))
  sometimes = lambda aug: iaa.Sometimes(0.5, aug)

  random_trns = iaa.SomeOf((0, 3), #(0,5) usually
  [
      sometimes(iaa.Superpixels(p_replace=(0, 0.2), n_segments=300)), # convert images into their superpixel representation
      iaa.OneOf([
          iaa.GaussianBlur((0, 3.0)), # blur images with a sigma between 0 and 3.0
          iaa.AverageBlur(k=(2, 7)), # blur image using local means with kernel sizes between 2 and 7
          iaa.MedianBlur(k=(3, 11)), # blur image using local medians with kernel sizes between 2 and 7
      ]),
      iaa.Sharpen(alpha=(0, 1.0), lightness=(0.75, 1.5)), # sharpen images
      #iaa.Emboss(alpha=(0, 1.0), strength=(0, 2.0)), # emboss images
      # search either for all edges or for directed edges,
      # blend the result with the original image using a blobby mask
      iaa.BlendAlphaSimplexNoise(iaa.OneOf([
          iaa.EdgeDetect(alpha=0.5),
          iaa.DirectedEdgeDetect(alpha=0.5, direction=(0.0, 1.0)),
      ])),
      iaa.AdditiveGaussianNoise(loc=0, scale=(0.0, 0.05*255), per_channel=0.5), # add gaussian noise to images
      iaa.OneOf([
          iaa.Dropout((0.01, 0.1), per_channel=0.5), # randomly remove up to 10% of the pixels
          iaa.CoarseDropout((0.03, 0.10), size_percent=(0.3, 0.5), per_channel=0.2),
      ]),
      iaa.Invert(0.05, per_channel=True), # invert color channels
      iaa.Add((-5, 10), per_channel=0.5), # change brightness of images (by -10 to 10 of original value)
      iaa.AddToHueAndSaturation((-20, 20)), # change hue and saturation
      # either change the brightness of the whole image (sometimes
      # per channel) or change the brightness of subareas

      iaa.LinearContrast((0.5, 2.0), per_channel=0.5), # improve or worsen the contrast
      iaa.Grayscale(alpha=(0.0, 1.0)),
      sometimes(iaa.ElasticTransformation(alpha=(0.5, 3.5), sigma=0.25)), # move pixels locally around (with random strengths)
      sometimes(iaa.PiecewiseAffine(scale=(0.01, 0.05))), # sometimes move parts of the image around
      sometimes(iaa.PerspectiveTransform(scale=(0.01, 0.1)))
  ],
  random_order=True
  )
  seq = iaa.Sequential([flipX, flipY, rot_image, shr, scale, translateX, translateY, random_trns]) #REMOVED random_trns
  return seq